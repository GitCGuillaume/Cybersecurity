//how T work
//The prover (e.g., token, soft token) and verifier (authentication
//or validation server) MUST know or be able to derive the current
//Unix time

// T:
//X represents the time step in seconds (default value X =
//30 seconds) and is a system parameter.
//o  T0 is the Unix time to start counting time steps (default value is
  // 0, i.e., the Unix epoch) and is also a system parameter.
//X 30 secs (in unix time type)
//T0 initial  counter
//T0 < Cur Unix Time
//T = (Current Unix time - T0) / X
//(now() - epoch) / 30
// R5 - There MUST be user-friendly mechanisms available to
//resynchronize the counter.  Section 7.4 and Appendix E.4 details the
//resynchronization mechanism proposed in this document
//T transform into hexadecimal

//How K part in TOTP work
// K:
//https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
//TOTP(K,T)
//HOTP(K,T) = Truncate(HMAC-SHA-1(K,T))
//T: at least u64
//R3: The algorithm MUST use HOTP [RFC4226] as a key building block.
//Do something with T
//call hmac-sha-1 type crypt with K secret
//must generate 6 digits code

//The Key (K), the Counter ((C) == (T)), and Data values are hashed high-order
//byte first. (because network communication work like this)

//The HOTP values generated by the HOTP generator are treated as big
//endian.

//ft truncate
//https://docs.rs/openssl/latest/openssl/sign/struct.Signer.html
//pub fn new<'a, T>(
//  type_: MessageDigest,
//  pkey: &PKeyRef<T>,
//) -> Result<Signer<'a>, ErrorStack>
//pub fn update(&mut self, buf: &[u8])
//pub fn sign(&self, buf: &mut [u8])
//follow this https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
//generate one time a T to try

//ft totp
use std::{array, io::Read, ops::Shl, time::SystemTime};
use openssl::{error::ErrorStack, hash::MessageDigest, pkey::{
  PKey,
  Private,
}, sha, sign::Signer
};
use crate::define;

fn dynamic_truncation(hmac: &Vec<u8>) {
  let mut dt: [u8; 4] = [0u8; 4];
}

fn generate_signer(key: &PKey<Private>, digest_type: MessageDigest) -> Result<Signer<'_>, ErrorStack> {
  let signer: Result<Signer<'_>, ErrorStack> = Signer::new(digest_type, key);

  signer
}

/* rfc [as a string?] */
fn generate_hmac(pkey: &[u8]) -> Result<PKey<Private>, ErrorStack> {
  let key: Result<PKey<Private>, ErrorStack> = PKey::hmac(pkey);

  key
}

fn totp(k: &[u8; define::UNCRYPTED_SIZE], T: u64) {
  //get hexa T
  let bytes: [u8; 8] = T.to_be_bytes();

}

/*
 * Apply T math from RFC 6238
 */
fn math_time() -> u64 {
  let time = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap();

  println!("now: {}", time.as_secs() / 30);
  return time.as_secs() / 30;
}


pub fn start_totp(/*digest: &[u8], */buf: &str) {
  /*let mut buff = Vec::new();
  buff.resize(define::UNCRYPTED_SIZE, 0);
  buff.copy_from_slice(buf);
  buff.truncate(64);
  buff.reserve(64);
  */let buf = hex::decode(&buf).unwrap();
  //let buf = buf.clone();
  println!("BUF:{}", String::from_utf8_lossy(&buf));

  /*let big_endian_buf: [u8; define::UNCRYPTED_SIZE] = buf.clone().map(|f|f.to_be());
  println!("BUF:{}", String::from_utf8_lossy(&big_endian_buf));
  if big_endian_buf.len() != define::UNCRYPTED_SIZE {
    //stop here
    eprintln!("Convert endianess should be of size {0}.", define::UNCRYPTED_SIZE);
    return ();
  }*/
 /* 
  let mut buff = Vec::new();
  buff.resize(define::UNCRYPTED_SIZE, 0);
  buff.copy_from_slice(buf);
  buff.truncate(64);
  buff.reserve(64);
  let buf = buff.clone();
  */
  println!("LENNNNN:{}", buf.len());
  let t = math_time();
  /*let mut hasher = sha::Sha1::new();
  hasher.update(&buf.clone());
  hasher.update(&t.to_be_bytes());
  let hmac: [u8; 20] = hasher.finish();

  if hmac.len() != 20 {
    eprintln!("HMAC-SHA-1 should be of size 20, currently: {0}", hmac.len());
    return ();
  }
  println!("hmac:{}", String::from_utf8_lossy(&hmac));
  let offset =  (hmac[19] & 0x0f) as usize;
  /* prend lowerbit */
  println!("ofs:{offset}");
  let mut val: u32;

  println!("{0:b} {1:b} {2:b} {3:b}", hmac[offset], hmac[offset+1], hmac[offset+2], hmac[offset+3]);
  //println!("{0:b} {1:b} {2:b} {3:b}", test[0] as u32, test[1] as u32, test[2] as u32, test[3] as u32);
  val = ((hmac[offset] & 0x7f) as u32).overflowing_shl(24).0
    | ((hmac[offset+1] & 0xff) as u32).overflowing_shl(16).0
    | ((hmac[offset+2] & 0xff) as u32).overflowing_shl(8).0
    | (hmac[offset+3] & 0xff) as u32;
  //println!("val:{0} {1}", val, val);
  // println!("val:{:b} {}", val, val);
  let binary:u32 = val % 1000000;
  println!("{0} {1}", binary, binary.to_be());
  let binary:u32 = val % 1000000;
  println!("{0} {1}", binary, binary.to_be());
*/
let mut val: u32;
  let res_key = PKey::hmac(&buf);

  match res_key {
      Ok(key) => {
        
        let res_signer = generate_signer(&key, MessageDigest::sha1());

        if let Ok(mut sign) = res_signer {
          sign.update(&t.to_be_bytes());
          //let upd = sign.update(&big_endian_buf).unwrap();
          let hmac = sign.sign_to_vec().unwrap();
          
          println!("size:{}", hmac.len());
          //err if len not 20
          if hmac.len() != 20 {
            eprintln!("HMAC-SHA-1 should be of size 20, currently: {0}", hmac.len());
          }
          /*unsafe {
          let _str = String::from_utf8_unchecked(hmac.clone());
          println!("hmac:{}", _str);
          }*/
          /*val = ((hmac[offset].to_be() & 0x7f) as u32).overflowing_shl(24).0
            | ((hmac[offset+1].to_be() & 0xff) as u32).overflowing_shl(16).0
            | ((hmac[offset+2].to_be() & 0xff) as u32).overflowing_shl(8).0
            | (hmac[offset+3].to_be() & 0xff) as u32;
          */
          let offset =  (hmac[19] & 0x0f) as usize;

          /*val = ((hmac[offset] & 0x7f) as u32).overflowing_shl(24).0
            | ((hmac[offset+1] & 0xff) as u32).overflowing_shl(16).0
            | ((hmac[offset+2] & 0xff) as u32).overflowing_shl(8).0
            | (hmac[offset+3] & 0xff) as u32;
          //println!("val:{0} {1}", val, val);
          // println!("val:{:b} {}", val, val);
          let binary:u32 = val % 1_000_000;
          println!("{0} {1}", binary, binary.to_be());
          let binary:u32 = val % 1_000_000;
          println!("{0} {1}", binary, binary.to_be());
*/
         /* let mut test: [u8; 4] = [0u8; 4];
          test[0] = hmac[offset];
          test[1] = hmac[offset+1];
          test[2] = hmac[offset+2];
          test[3] = hmac[offset+3];
          //println!("{0:b} {1:b} {2:b} {3:b}", test[0], test[1], test[2], test[3]);
          //println!("{0:b} {1:b} {2:b} {3:b}", test[0].to_be(), test[1].to_be(), test[2].to_be(), test[3].to_be());
          val = u32::from_be_bytes([test[0],test[1],test[2],test[3]]) & 0x7fff_ffff;
          //println!("val:{0} {1}", val, val);
          let binary:u32 = val % 1_000_000;
          println!("{0} {1}", binary, binary.to_be());
          val = u32::from_be_bytes([test[0],test[1],test[2],test[3]]) & 0xFFFFFFFE;
          //println!("val:{0} {1}", val, val);
          let binary:u32 = val % 1_000_000;
          println!("{0} {1}", binary, binary.to_be());
*/
          val = u32::from_be_bytes(hmac[offset..offset+4].try_into().unwrap()) & 0x7fff_ffff;
          //println!("val:{0} {1}", val, val);
          let binary:u32 = val % 1000000;
          let len = u32::ilog10(binary) + 1;
          for i in len..6 {
            print!("0");
          }
          println!("{0}", binary,);
          /*val = u32::from_be_bytes(hmac[offset..offset+4].try_into().unwrap()) & 0xffff_fffe;
          //println!("val:{0} {1}", val, val);
          let binary:u32 = val % 1000000;
          println!("{0} {1}", binary, binary.to_be());



          
          let mut hasher = sha::Sha1::new();
          hasher.update(&buf.clone());
          hasher.update(&t.to_be_bytes());
          let hmac: [u8; 20] = hasher.finish();
          if hmac.len() != 20 {
            eprintln!("HMAC-SHA-1 should be of size 20, currently: {0}", hmac.len());
            return ();
          }
          let _str = String::from_utf8_lossy(&hmac);
          println!("hmac:{}", _str);
          let offset =  (hmac[19] & 0x0f) as usize;
          let mut test: [u8; 4] = [0u8; 4];
          test[0] = hmac[offset];
          test[1] = hmac[offset+1];
          test[2] = hmac[offset+2];
          test[3] = hmac[offset+3];
          //println!("{0:b} {1:b} {2:b} {3:b}", test[0], test[1], test[2], test[3]);
          //println!("{0:b} {1:b} {2:b} {3:b}", test[0].to_be(), test[1].to_be(), test[2].to_be(), test[3].to_be());
          val = u32::from_be_bytes([test[0],test[1],test[2],test[3]]) & & 0x7fff_ffff;
          //println!("val:{0} {1}", val, val);
          let binary:u32 = val % 1_000_000;
          println!("{0} {1}", binary, binary.to_be());
          val = u32::from_be_bytes([test[0],test[1],test[2],test[3]]) & & 0xFFFFFFFE;
          //println!("val:{0} {1}", val, val);
          let binary:u32 = val % 1_000_000;
          println!("{0} {1}", binary, binary.to_be());

          val = u32::from_be_bytes(hmac[offset..offset+4].try_into().unwrap()) & 0x7fff_ffff;
          //println!("val:{0} {1}", val, val);
          let binary:u32 = val % 1_000_000;
          println!("{0} {1}", binary, binary.to_be());
          val = u32::from_be_bytes(hmac[offset..offset+4].try_into().unwrap()) & 0xFFFFFFFE;
          //println!("val:{0} {1}", val, val);
          let binary:u32 = val % 1_000_000;
          println!("{0} {1}", binary, binary.to_be());*/
        } else {
          println!("Couldn't sign value.");
        }
      },
      Err(e) => eprintln!("Error: {e}"),
  }
  


 // totp(buf, t);
}