//how T work
//The prover (e.g., token, soft token) and verifier (authentication
//or validation server) MUST know or be able to derive the current
//Unix time

// T:
//X represents the time step in seconds (default value X =
//30 seconds) and is a system parameter.
//o  T0 is the Unix time to start counting time steps (default value is
  // 0, i.e., the Unix epoch) and is also a system parameter.
//X 30 secs (in unix time type)
//T0 initial  counter
//T0 < Cur Unix Time
//T = (Current Unix time - T0) / X
//(now() - epoch) / 30
// R5 - There MUST be user-friendly mechanisms available to
//resynchronize the counter.  Section 7.4 and Appendix E.4 details the
//resynchronization mechanism proposed in this document
//T transform into hexadecimal

//How K part in TOTP work
// K:
//https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
//TOTP(K,T)
//HOTP(K,T) = Truncate(HMAC-SHA-1(K,T))
//T: at least u64
//R3: The algorithm MUST use HOTP [RFC4226] as a key building block.
//Do something with T
//call hmac-sha-1 type crypt with K secret
//must generate 6 digits code

//The Key (K), the Counter ((C) == (T)), and Data values are hashed high-order
//byte first. (because network communication work like this)

//The HOTP values generated by the HOTP generator are treated as big
//endian.

//ft truncate
//https://docs.rs/openssl/latest/openssl/sign/struct.Signer.html
//pub fn new<'a, T>(
//  type_: MessageDigest,
//  pkey: &PKeyRef<T>,
//) -> Result<Signer<'a>, ErrorStack>
//pub fn update(&mut self, buf: &[u8])
//pub fn sign(&self, buf: &mut [u8])
//follow this https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
//generate one time a T to try

//ft totp
use std::time::SystemTime;
use openssl::{error::ErrorStack, hash::MessageDigest, pkey::{
  PKey,
  Private,
}, sha, sign::Signer
};
use crate::define;
/* 
fn dynamic_truncation(hmac: &Vec<u8>) {
  let mut dt: [u8; 4] = [0u8; 4];
}

fn generate_signer(key: &PKey<Private>, digest_type: MessageDigest) -> Result<Signer<'_>, ErrorStack> {
  let signer: Result<Signer<'_>, ErrorStack> = Signer::new(digest_type, key);

  signer
}

/* rfc [as a string?] */
fn generate_hmac(digest: &[u8; define::UNCRYPTED_SIZE]) -> Result<PKey<Private>, ErrorStack> {
  let key: Result<PKey<Private>, ErrorStack> = PKey::hmac(digest);

  key
}

fn totp(k: &[u8; define::UNCRYPTED_SIZE], T: u64) {
  //get hexa T
  let bytes: [u8; 8] = T.to_be_bytes();

}*/

/*
 * Apply T math from RFC 6238
 */
fn math_time() -> u64 {
  let time = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap();

  println!("now: {}", time.as_secs() / 30);
  return time.as_secs() / 30;
}

pub fn start_totp(/*digest: &[u8], */buf: &[u8; define::UNCRYPTED_SIZE]) {
  let big_endian_buf: [u8; define::UNCRYPTED_SIZE] = buf.map(|f|f.to_be());

  if big_endian_buf.len() != define::UNCRYPTED_SIZE {
    //stop here
    eprintln!("Convert endianess should be of size {0}.", define::UNCRYPTED_SIZE);
    return ();
  }
  let t = math_time();
  let mut hasher = sha::Sha1::new();
  hasher.update(&big_endian_buf);
  hasher.update(&t.to_be_bytes());
  let hmac: [u8; 20] = hasher.finish();
  if hmac.len() != 20 {
    eprintln!("HMAC-SHA-1 should be of size 20, currently: {0}", hmac.len());
    return ();
  }
  //let aze = String::from_utf8_lossy(&hmac);
  let offset: usize =  (hmac[19] & 0x0f) as usize;
  //let dix: u32 = 10;
  //binary = binary % dix.pow(6);
  //println!("b:{binary}");
  /*let res_key = generate_hmac(&big_endian_buf);

  match res_key {
      Ok(key) => {
        
        /*let res_signer = generate_signer(&key, MessageDigest::sha1());

        if let Ok(mut sign) = res_signer {
          let upd = sign.update(&t.to_be_bytes()).unwrap();
          //let upd = sign.update(&big_endian_buf).unwrap();
          let hmac = sign.sign_to_vec().unwrap();
          println!("size:{}", hmac.len());
          //err if len not 20
          if hmac.len() != 20 {
            eprintln!("HMAC-SHA-1 should be of size 20, currently: {0}", hmac.len());
          }
        } else {
          println!("Couldn't sign value.");
        }*/
      },
      Err(e) => eprintln!("Error: {e}"),
  }*/
  


 // totp(buf, t);
}