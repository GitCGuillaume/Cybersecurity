//how T work
//The prover (e.g., token, soft token) and verifier (authentication
//or validation server) MUST know or be able to derive the current
//Unix time

// T:
//X represents the time step in seconds (default value X =
//30 seconds) and is a system parameter.
//o  T0 is the Unix time to start counting time steps (default value is
  // 0, i.e., the Unix epoch) and is also a system parameter.
//X 30 secs (in unix time type)
//T0 initial  counter
//T0 < Cur Unix Time
//T = (Current Unix time - T0) / X
//(now() - epoch) / 30
// R5 - There MUST be user-friendly mechanisms available to
//resynchronize the counter.  Section 7.4 and Appendix E.4 details the
//resynchronization mechanism proposed in this document

//How K part in TOTP work
// K:
//https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
//TOTP(K,T)
//HOTP(K,T) = Truncate(HMAC-SHA-1(K,T))
//T: at least u64
//R3: The algorithm MUST use HOTP [RFC4226] as a key building block.
//Do something with T
//call hmac-sha-1 type crypt with K secret
//must generate 6 digits code

//The Key (K), the Counter ((C) == (T)), and Data values are hashed high-order
//byte first. (because network communication work like this)

//The HOTP values generated by the HOTP generator are treated as big
//endian.

//ft truncate
//https://docs.rs/openssl/latest/openssl/sign/struct.Signer.html
//pub fn new<'a, T>(
//  type_: MessageDigest,
//  pkey: &PKeyRef<T>,
//) -> Result<Signer<'a>, ErrorStack>
//pub fn update(&mut self, buf: &[u8])
//pub fn sign(&self, buf: &mut [u8])
//follow this https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
//generate one time a T to try

//ft totp
use std::time::SystemTime;
use crate::define;

fn totp(k: &[u8; define::UNCRYPTED_SIZE], T: u64) {
  
}

/*
 * Apply T math from RFC 6238
 */
fn math_time() -> u64 {
  let time = SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap();

  println!("now: {}", time.as_secs() / 30);
  return time.as_secs() / 30;
}

pub fn start_totp(buf: &[u8; define::UNCRYPTED_SIZE]) {
  let t = math_time();

  totp(buf, t);
}